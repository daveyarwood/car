#!/usr/bin/env boot
; -*- mode: Clojure;-*-

(set-env!
  :dependencies #(into % '[[jarohen/nomad "0.7.0"]
                           [defun "0.2.0-RC"]
                           [io.aviso/pretty "0.1.17"]]))

(require '[nomad :refer (defconfig)]
         '[clojure.java.io :as io]
         '[clojure.string :as str]
         '[defun :refer (defun)]
         '[io.aviso.ansi :refer :all])

(def CONFIG-PATH (str (System/getenv "HOME") "/.config/car/config.edn"))

(defconfig config (io/file CONFIG-PATH))

(defn set-current-mileage!
  [mileage]
  (spit CONFIG-PATH (assoc-in (config) [:current] mileage)))

(defn parse-number-or-fail
  [n & {:keys [on-fail]}]
  (try
    (Integer/parseInt n)
    (catch NumberFormatException e
      (println n "isn't a number...")
      (if on-fail (on-fail) (System/exit 1)))))

(defn ask-for-current-mileage!
  []
  (print "Enter current odometer reading: ") (flush)
  (let [new-mileage (parse-number-or-fail (read-line)
                                          :on-fail ask-for-current-mileage!)]
    (set-current-mileage! new-mileage)
    new-mileage))

(defn get-current-mileage!
  []
  (if-let [from-config (:current (config))]
    from-config
    (ask-for-current-mileage!)))

(defn normalize-task-name
  [task-name]
  (str/lower-case (str/replace task-name #"[^\w]" "")))

(defn find-task-by-query
  "Returns the first task found in config-map that has the same normalized name
   as task-query. e.g. the query 'oil-change' will find the task 'Oil change'."
  [task-query]
  (first (keep-indexed (fn [i {task-name :name :as task-map}]
                         (when (= (normalize-task-name task-name)
                                  (normalize-task-name task-query))
                           (assoc task-map :id i)))
                       (:tasks (config)))))

(defn regular-task?
  [task-query]
  (boolean (get-in (find-task-by-query task-query) [:interval])))

(defn recorded-task?
  [task-query]
  (boolean (get-in (find-task-by-query task-query) [:last-done])))

(defn overdue?
  [task-query]
  {:pre [(and (regular-task? task-query) (recorded-task? task-query))]}
  (let [{:keys [interval last-done]} (find-task-by-query task-query)
        current-mileage (get-current-mileage!)
        time-since-last (- current-mileage last-done)]
    (>= time-since-last interval)))

(defn maintenance-schedule
  "Returns an infinite lazy sequence of all the mile markers when a regular
   task is due, starting from the last time it was done."
  [task-query]
  {:pre [(and (regular-task? task-query) (recorded-task? task-query))]}
  (let [{:keys [interval last-done]} (find-task-by-query task-query)]
    (iterate (partial + interval) last-done)))

(defn next-due
  "Returns the next mile marker when a regular task is due."
  [task-query current-mileage]
  {:pre [(and (regular-task? task-query) (recorded-task? task-query))]}
  (if (overdue? task-query)
    (let [{:keys [last-done interval]} (find-task-by-query task-query)]
      (+ last-done interval))
    (first (drop-while #(<= % current-mileage) (maintenance-schedule task-query)))))

(defn update-last-done!
  [task-query mileage]
  {:pre [(recorded-task? task-query)]}
  (let [{task-name :name, id :id} (find-task-by-query task-query)]
    (spit CONFIG-PATH (assoc-in (config) [:tasks id :last-done] mileage))))

(defn new-task!
  "Adds a new task to the config, along with any values supplied in the format
   foo=bar or foo:bar.

   e.g.
   (new-task! 'Replace cabin air filter' last-done=90000 interval=15000)"
  [task-name & configs]
  (let [task (apply merge {:name task-name}
                          (map (fn [cfg]
                                 (let [[k v] (str/split cfg #"[=:]")]
                                   {(keyword k) (try
                                                  (Integer/parseInt v)
                                                  (catch NumberFormatException e v))}))
                               configs))]
    (spit CONFIG-PATH (update-in (config) [:tasks] conj task))))

(defun -main
  ([]
    (-main "current")
    (doseq [{task-name :name} (filter :interval (:tasks (config)))]
      (-main task-name)))

  (["current"]
    (let [current-mileage (get-current-mileage!)]
      (println (str (blue-bg (black "Current mileage")) \:)
               (white-bg (bold-black current-mileage)))))
  (["current" n]
    (let [new-mileage (parse-number-or-fail n)]
      (set-current-mileage! new-mileage)
      (-main "current")))

  (["last"]
    (-main "current")
    (doseq [{task-name :name} (filter :interval (:tasks (config)))]
      (-main "last" task-name)))
  (["last" (task :guard recorded-task?)]
    (let [{task-name :name, last-done :last-done} (find-task-by-query task)
          current-mileage (get-current-mileage!)]
      (println (str task-name \:) "last done at" (green last-done))))
  (["last" task] (-main :unknown task))
  (["last" (task :guard recorded-task?) n]
    (let [new-mileage (parse-number-or-fail n)]
      (update-last-done! task new-mileage)
      (-main "last" task)))

  (["add" task-name & configs]
    (apply new-task! task-name configs)
    (println "Added task" (str task-name \.)))

  ([(task :guard regular-task?)]
    (let [{:keys [name interval last-done]} (find-task-by-query task)
          current-mileage (get-current-mileage!)
          task-due (next-due task current-mileage)]
      (set-current-mileage! current-mileage)
      (println (str (cyan-bg (black name)) \:)
               "last done at" (green (str last-done \,))
               (if (overdue? task)
                 (str (red "was due at") \space (bold-red task-due))
                 (str "due at " (green task-due))))))
  ([(task :guard recorded-task?)]
    (-main "last" task))
  ([(task :guard recorded-task?) n]
    (-main "last" task n))

  ([:unknown task] (println "I don't know what" task "is."))
  ([task] (-main :unknown task))
  ([_ & more] (println "lol wut?")))
